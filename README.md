# C++

## 개요
C++은 C언어를 기초로 삼아 만든 언어이므로, 기존의 C 표준 라이브러리를 그대로 사용할 수 있습니다.
타입, 연산자, 제어문, 포인터 등의 주요 문법을 C언어에서 가져왔기 때문에 C언어에 대한 기초를 알고 있으면 좋습니다

1. C++은 절차 지향적이며 구조적 프로그래밍 언어입니다.
2. C++은 객체 지향 프로그래밍 언어입니다.
3. C++은 일반화 프로그래밍 언어입니다.

---
## C 언어와 C++ 의 차이점
| | C | C++|
|-|-|-|
|주석(코멘트 기입방법)|`/* */`|`/* */`, `//`|
|함수를 정의하기 전에 <br> 함수의 호출이 있는 경우 <br> 함수의 [프로토타입 선언](#프로토타입-선언)| 컴파일 에러 발생 X |컴파일 에러 발생 O <br> 반드시 프로토타입을 선언해야함|
|지역 변수 선언|`{}`로 에워싼 블록의 선두에서만|블록 내의 어느 곳에서나 가능하나<br>변수 선언은 변수 사용 직전에 하기를 권장<pre><code>int Number <br>Number = 3;</code></pre>|
|카운터를 for문 안에 선언|블록을 시작하고 카운터 선언|for문 안에 카운터 선언<pre><code>for(<U>**int i=0**</U>; i<=5;i++>)</code></pre>|
|#define 대신 const 사용|수치를 정의 할 때 #define 사용|수치를 정의 할 때 const 로 대신 사용 및 권장|
|[헤더 파일(Header file)](#헤더-파일header-file)|헤더파일 임포트가 필요|헤더파일 임포트 불필요 <br>같은 프로젝트에 cs 파일일 경우 자동으로 인식 후 컴파일함|
|클래스 상속에서 키워드 사용???|부모 클래스에서 virtual<br>자식 클래스에서 virtual 와 override<br>자식의 자식 클래스도 virtual 과 override |부모 클래스에서 virtual<br>자식 클래스에서 override<br>자식의 자식 클래스에서도 override|
|delete 연산자|메모리에 블록 할당 취소에 사용|[가비지 컬렉터(Garbage Collector)](#가비지-컬렉터garbage-collector)가 메모리를 사용하지 않는 시점에 알아서 삭제함|
|구조체(Struct)???|상속 가능|상속 불가능|
|new 키워드<br>struct 와 class 선언시 어떤 차이가 있는지 확인???|힙 메모리에 포인터 생성|객체 생성|
|상속관계일 때<br>생성자와 함수 선언 및 호출<br>3개의 상속 클래스로 테스트 해보기???|||
|c# 에서 2개로 분리된 클래스를 using 을 사용해 참조하면 분리된 클래스중에 하나만 인식한다는데 확인 필요??? |||
|[namespace](#네임스페이스namespace)|없음|있음|
|[디폴트 인수(default argument)](#디폴트-인수default-argument)|없음|있음|
|Generic Programing???|Template|Generic|
|클래스에서 접근 한정자 지정 위치???|||
|delegate???|||
|Event???|||

## const
- 배열이나 포인터를 매개변수로 넘겨줄 때, const 를 사용하면 함수 내에서 수정이 불가한 읽기 전용으로 만들 수 있음
- const 를 지정한 포인터를 일반 포인터에 대입하려고 하면 컴파일 에러 남
```C++
void ChangeString(const char* ptr)
{
    char* buf;
    buf = *ptr; // 컴파일 에러
    buf[0] ='b' // 위에서 컴파일 에러가 발생하지 않으면 const 를 지정한 포인터의 값이 변경됨 
}
```

## literal
- 정수 리터럴
``` C++
int num1 = 10;    // 10진수 10
int num2 = 0x3EB;    // 16진수 3EB
int num3 = 0b1101   // 2진수 1101
```
- 문자열 리터럴
```C++
char str1[] = "Hi";   // ASCII 코드
char str2[] = u8"Hi";   // 선두에 U8을 붙이면 UTF-8
char str3[] = u"Hi";    // 선두에 u를 붙이면 UTF-16
char str4[] = U"Hi";    // 선두에 U를 붙이면 UTF-32
char16_t char1; // UTF-16 문자를 표현하기 위한 문자형
char32_t char2; // UTF-32 문자를 표현하기 위한 문자형
```
- 에스케이프 문자를 무시하는 리터럴 R"()"
```C++
printf("C:\\github");   // C:\github 로 출력
printf(R"(C:\github)");   // C:\github 로 출력
```

## enum
- 열거형 요소에 임의의 수를 지정하면 그 수에서부터 1씩 증가하는 정수가 됨
  ```C++
  enum Colors {Red, Green = 10, Yellow, Blue= 20, Purple}; // 0, 10, 11, 20, 21
  ```
- enum class
  - enum 과는 다르게 각 요소의 유효 범위가 해당 열거형 내부로만 한정됨
    ```C++
    enum Colors {Red, Blue, Green};    
    enum LightColors {Red, Blue, Green}; // enum 을 사용하면 요소 이름을 중복하여 사용불가
    // enum class 는 다른 enum class 에서 요소 이름 중복 가능
    enum class Colors {Red, Blue, Green};    
    enum class LightColors {Red, Blue, Green}; 
                :
    Colors bookColor = Colors::Red; // 어떤 열거형인지 지정
    ```

## this
- this 를 기술한 오브젝트 자체를 가리키는 포인터




---
#### 프로토타입 선언
> ##### 함수의 이름과 형태를 컴파일러에게 알려주는 것
> ##### 함수의 내용을 정의하기 전에 '*함수의 호출 방법* '을 미리 기술해 두는 것
> ##### 함수를 호출하기 전에 '*함수의 정의* '가 없을 경우, 반드시 프로토 타입을 선언해야됨
#### 헤더 파일(Header file)
> ##### 프로그래밍에서의 정보 파일로 프로그램의 최초에 있으며, 그 프로그램 중의 함수가 사용하는 데이터의 형이나 변수의 정의가 들어있다
#### 가비지 컬렉터(Garbage Collector)
> ##### 애플리케이션의 메모리 할당 및 해제를 관리
#### 네임스페이스(namespace)
> ##### 내부 식별자에 사용될 수 있는 유효 범위를 제공하는 선언적 영역을 의미한다
> ##### 전역 위치뿐만 아니라 다른 네임스페이스 내에서도 정의될 수 있다
> ##### 블록 내에서는 정의될 수 없으며, 기본적으로 외부 연결을 가지게 된다
> ##### 일반적으로 헤더 파일에서 정의되며, 언제나 새로운 이름을 추가할 수 있도록 개방되어 있다
> ##### C++ 표준 라이브러리 타입과 함수들은 std 네임스페이스 또는 그 속에 중첩된 네임스페이스에 선언되어 있다
> ##### 네임스페이스에 접근하기 위해서는 범위지정 연산자(::, scope resolution operator)를 사용하여 해당 이름을 특정 네임스페이스로 제한하면 된다
> ```C++
> std::cout << "Hi" << endl;
> ```
> ##### using 지시자(directive)
>> ##### 명시한 네임스페이스에 속한 이름을 모두 가져와 범위 지정 연산자를 사용하지 않고도 사용할 수 있게 해준다
>> ##### 전역 범위에서 사용된 using 지시자는 해당 네임스페이스의 모든 이름을 전역적으로 사용할 수 있게 만들어 준다
>> ##### 블록 내에서 사용된 using 지시자는 해당 블록에서만 해당 네임스페이스의 모든 이름을 사용할 수 있게 해준다
>> ```C++
>> using namespace std;
>> ```

> ##### using 선언(declaration)
>> ##### 단 하나의 이름만을 범위지정 연산자를 사용하지 않고도 사용할 수 있게 해준다
>> ##### using 선언이 전역 범위에 사용되면 해당 이름을 전역적으로 사용가능하고, 블록 내에서 선언되면 블록 내에서만 사용가능하다
>> ```C++
>> using std::cout;
>> ```
#### 디폴트 인수(Default argument)
> ##### 기본값이 미리 정의되어 있는 인수를 의미한다
> ##### 함수를 호출할 때 인수를 전달하지 않으면, 함수는 자동으로 미리 정의되어 있는 디폴트 인수값을 사용하게 된다
> ##### 프로토타입 및 함수의 정의 모두에서 설정 가능하다
> ##### 일부 인수에만 디폴트 인수를 설정할 수 있으나 디폴트 인수들은 인수들의 끝쪽(오른쪽)에 배치하여야 한다
> ```c++
> void Display(int x, int y = 1, int z);  // 오류
> ```
> ##### 특정 디폴트 인수를 생략하면 해당 인수 뒤에 오는 모든 인수도 생략하여야 한다
> ```c++
> void Display(int x, int y = 1, int z = 3);
> 
> Display(1, ,7); // 오류
> ```


---
[C 언어와 C++ 의 차이점](#c-언어와-c-의-차이점) <!-- +기호를 없애야 링크 연결됨 -->